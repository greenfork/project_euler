(import srfi-1 (chicken bitwise))

(define (triangle-number n)
  (cond
   ((< n 2) 1)
   (else (quotient (* n (add1 n)) 2))))
(assert (= (triangle-number 7) 28))

(define (div? n k)
  (receive (q r) (quotient&remainder n k)
	(= 0 r)))
(assert (div? 6 3))
(assert (not (div? 15 7)))

(define (add-factors factors n k)
  (do ((m n (quotient m k)))
	  ((not (div? m k)) (set! n m))
	(set! factors (cons k factors)))
  (values factors n))
(assert (equal? (receive (factors n) (add-factors '() 12 2) (list factors n))
				'((2 2) 3)))

(define (wheel-factorization n)
  (let ((basis '(2 3 5))
		(q 7)
		(circ (circular-list 4 2 4 2 4 6 2 6))
		(factors '())
		(m n))
	(letrec ((F (lambda (k)
				  (receive (factors-new m-new) (add-factors factors m k)
					(set! factors factors-new)
					(set! m m-new)))))
	  (for-each F basis)
	  (let loop ((k q) (circ circ))
		(when (<= k m)
		  (F k)
		  (loop (+ k (car circ)) (cdr circ)))))
	factors))
(assert (let ((p '(23 19 17 13 11 7 7 5 3 2 2)))
		  (equal? (wheel-factorization (apply * p)) p)))
(assert (equal? (wheel-factorization 28) '(7 2 2)))

(define (gray-code v indices)
  (let ((set '()))
	(let loop ((l (sub1 (vector-length v))))
	  (when (>= l 0)
		(when (bit->boolean indices l)
		  (set! set (cons (vector-ref v l) set)))
		(loop (sub1 l))))
	set))
(assert (equal? (gray-code #(7 5 3 3 2) #b10101) '(7 3 2)))
(assert (equal? (gray-code #(7 5 3 3 2) #b01010) '(5 3)))

(define (cons-uniq a l)
  (if (member a l equal?) l (cons a l)))
(assert (equal? (cons-uniq '(1 2) '((1 2) (2 3))) '((1 2) (2 3))))
(assert (equal? (cons-uniq '(1 2) '((2 3))) '((1 2) (2 3))))

(define (^ a n)
  (letrec ((E (lambda (n p)
				(cond
				 ((zero? n) p)
				 (else (E (sub1 n) (* a p)))))))
	(E n 1)))
(assert (= (^ 2 4) 16))
(assert (= (^ 3 3) 27))

(define (power-set l)
  (letrec ((P (lambda (v indices pset)
				(cond
				 ((zero? indices) pset)
				 (else (P
						v
						(sub1 indices)
						(cons-uniq (gray-code v indices) pset)))))))
   (P (list->vector l) (^ 2 (length l)) '(()))))
(assert (equal? (power-set '(5 3 2)) '((5) (3) (5 3) (2) (5 2) (3 2) (5 3 2) ())))
(assert (equal? (power-set '(7 2 2)) '((7) (2) (7 2) (2 2) (7 2 2) ())))

(define (main limit)
  (print
   (call/cc
	(lambda (k)
	  (let loop ((n 1))
		(let* ((triangle-n (triangle-number n))
			   (factors (wheel-factorization triangle-n))
			   (power-s (power-set factors))
			   (divisors-count (length power-s)))
		  ;; (print "n: " n " triangle-n: " triangle-n " factors: " factors " divisors-count: " divisors-count)
		  (if (> divisors-count limit)
			  (k triangle-n)
			  (loop (add1 n)))))))))
